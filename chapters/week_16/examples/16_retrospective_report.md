# 示例 2：工程复盘报告（KPT 复盘法）

## 问题场景

16 周结束了，CampusFlow 交付了。但代码提交不是终点——**真正的学习发生在你回头审视这些决策的时候**。

为什么当初选择 SQLite 而不是 JSON 文件？为什么 Week 10 的 AI 生成前端改了 3 轮才通过？这些"为什么"如果不记录下来，下周就会忘。

工程复盘（Retrospective）就是用结构化的方法回答：**什么做得好？什么可以改进？下次怎么做更好？**

## 核心概念

**KPT 复盘法**：一种简单的复盘框架，来自日本的敏捷实践。

| 维度 | 含义 | 示例问题 |
|------|------|----------|
| **Keep** | 做得好的、要保持的 | 哪些实践帮团队节省了时间？ |
| **Problem** | 遇到的、需要改进的问题 | 哪些决策导致了返工？ |
| **Try** | 下次尝试的新方法 | 有没有什么工具/流程想试？ |

## 使用示例

下面是 CampusFlow 团队 Week 02-16 的完整复盘报告：

```markdown
# CampusFlow 工程复盘报告
# Week 02 - Week 16

## 团队信息
- 项目：CampusFlow（会议室预约系统）
- 成员：小北（后端）、阿码（全栈）、老潘（架构）
- 复盘日期：2026年1月
- 方法论：KPT 复盘法

---

## Keep（做得好的，继续坚持）

### 1. ADR 驱动的架构决策
**实践**：每两周写一篇 ADR，记录背景、决策、后果。

**效果**：
- Week 06 时小北想改领域模型，翻开 ADR-001 发现"User 和 Booking 必须分离"的设计理由，避免了盲目重构
- Week 12 集成测试时，ADR-003 的 API 设计文档直接变成测试用例来源
- 项目集市上，评委问"为什么用 SQLite"，阿码直接拿出 ADR-002："这是我们当时的 3 个备选方案对比"

**下次继续**：
- 仍然用 ADR 记录重要决策
- 改进：ADR 里可以加"决策日期"和"决策人"，方便追溯

---

### 2. 首席架构师轮换制
**实践**：每两周换一个人当首席架构师，负责当期 ADR 和设计决策。

**效果**：
- Week 02-03：小北做领域模型，学到了"名词提取法"
- Week 04-05：阿码设计数据层，发现"Repository 模式"比直接写 JDBC 更优雅
- Week 06-07：老潘设计 API，坚持 RESTful 风格，被评委表扬"接口设计规范"
- Week 08-09：小北做架构演进，学会了"用策略模式替代 if-else"

**意外收获**：
- 每个人都有"说了算"的体验，避免了争吵
- 轮换前后的交接会议成了团队知识分享时刻

---

### 3. Feature Branch 工作流
**实践**：每个功能独立分支，完成后提 PR，必须 Code Review 通过才能合并。

**效果**：
- Week 04 第一次合并冲突花了 2 小时解决
- Week 08 后冲突变少，因为大家养成了"先 pull 再 push"的习惯
- Week 14 发布前，Git log 历史清晰，每个功能都能找到对应 commit

**老潘点评**：
> "在公司里，如果 Git 历史一团糟，出了问题根本没法回滚。你们现在的习惯很职业。"

---

### 4. 测试先行（TDD Light）
**实践**：不是严格的 TDD，但"先写测试再写实现"的意识建立了。

**效果**：
- Week 06 覆盖率 70%，Week 11 达到 85%
- Week 12 Bug Bash 时，有测试的模块 0 bug，没测试的模块 7 个 bug
- Week 14 重构时，测试网保住了逻辑正确性

**数据**：
- 测试用例总数：127 个
- 覆盖率：87%（行）、81%（分支）
- Bug Bash 发现的 15 个 bug，0 个回归

---

### 5. AI 审查检查清单
**实践**：Week 10 前端代码用 AI 生成，然后用 5 维检查清单人工审查。

**效果**：
- AI 生成的代码第一版有 3 个安全漏洞（XSS、CORS、SQL 注入风险）
- 用检查清单逐项排查，全部修复
- Week 13 文档也用 AI 生成，检查清单帮发现了 3 处"幻觉"（调用不存在的 API）

**阿码的反思**：
> "刚开始觉得 AI 审查是走过场，真正踩坑后才明白：AI 能干活，但不能背锅。"

---

## Problem（遇到的问题，需要改进）

### 1. 需求蔓延（Scope Creep）
**问题**：Week 04 只有 3 个核心功能，Week 12 变成了 12 个功能。

**后果**：
- Week 13 还在加功能，文档和测试没时间完善
- Week 14 发布前发现"预约提醒"功能有 bug，但没时间修
- 演示时 10 分钟讲不完所有功能，观众注意力分散

**根因分析**：
| 原因 | 证据 |
|------|------|
| 没有明确的"v1.0 边界" | 每次有人提建议，都说"这个好做，加吧" |
| 缺少"拒绝"机制 | 没有人站出来说"这个放到 v1.1" |
| 时间预估不准 | 以为"预约提醒"只要 2 天，实际花了 5 天 |

**下次改进**：
- Week 04 立项时就写死 v1.0 的功能清单（3-5 个核心功能）
- 任何新需求都记录到"Backlog"，不立即实现
- 用 MoSCoW 方法分类：Must have / Should have / Could have / Won't have

---

### 2. AI 幻觉导致返工
**问题**：Week 10 让 AI 生成前端代码，结果调用了不存在的 API。

**后果**：
- 前端写了 3 天，联调时发现后端没有对应接口
- 阿码坚持"AI 说是这样的"，小北查了 OpenAPI 文档，确实没有
- 最后返工 2 天，修改前端调用正确的 API

**根因**：
- 阿码没有先审查 AI 代码，直接复制粘贴
- 团队没有约定"AI 代码必须先审查再提交"
- Week 09 的 API 文档没及时更新，AI 训练数据可能来自旧版本

**下次改进**：
- AI 生成的代码必须走 Code Review 流程
- 先在隔离环境跑通再集成到主项目
- API 文档每次变更都要同步到 OpenAPI 规范

---

### 3. 测试数据管理混乱
**问题**：Week 12 集成测试时，每次运行都要手动清理数据库。

**后果**：
- 测试之间互相影响，时好时坏
- CI 上偶尔失败，本地复现不了
- Bug Bash 时发现"某个预约 ID 永远约不了"，原来是因为测试数据没清理

**根因**：
- 没有用内存数据库（H2）做测试
- 每个测试的 `@BeforeEach` 没有正确清理数据
- 测试用例之间有依赖（测试 A 的数据影响测试 B）

**下次改进**：
- Week 17 重构时，引入 H2 作为测试数据库
- 每个 `@Test` 方法独立，不共享数据
- 用 TestContainers 做真数据库集成测试（生产环境验证）

---

### 4. 演示准备仓促
**问题**：Week 15 演示脚本前一天晚上才写完。

**后果**：
- 演示时超时，评委在最后 1 分钟打断
- Q&A 环节准备不足，有个评委问"你们怎么做压力测试"，答不上来
- 海报和 PPT 风格不统一，看起来临时拼凑

**根因**：
- Week 14 才结束功能开发，没时间准备展示材料
- 没有人提前分工"谁写脚本、谁做 PPT、谁练演讲"
- 以为"功能做好了自然会讲"，实际上"怎么讲"需要练习

**下次改进**：
- Week 12 就开始准备展示材料（功能冻结 → 材料准备 → 练习）
- 用"外部评审"做演习：找其他团队来听，提前发现问题
- 备用演示视频：如果现场网络出问题，可以录屏播放

---

### 5. 文档滞后于代码
**问题**：Week 13 发现 README 还是 Week 04 的版本。

**后果**：
- 新成员（阿码的室友想加入）抱怨"文档和代码对不上"
- API 文档里的 3 个接口已经废弃，但文档没更新
- 演示时评委问"怎么部署"，阿码现场查文档，发现步骤已经过时

**根因**：
- 没有把"文档更新"加入 DoD（Definition of Done）
- 总是想着"代码写完再更新文档"，但永远"没时间"
- 没有用自动化工具检查文档一致性

**下次改进**：
- PR 必须包含相关文档更新，否则不合并
- 用 Swagger UI 自动生成 API 文档
- 每次发布前跑"文档审查检查清单"

---

## Try（下次尝试的方法）

### 1. 引入 CI/CD 工具
**目标**：Week 11 用了本地质量门禁，Week 17 想试试 GitHub Actions。

**计划**：
- Week 17：配置自动化测试 + 覆盖率检查
- Week 18：加入自动部署（推送到 main 分支自动部署到演示环境）
- 期待：减少手动操作，降低发布错误

---

### 2. 用工程指标（DORA）衡量团队效能
**目标**：不只是"感觉这次比上次好"，而是有数据支撑。

**指标**：
| DORA 指标 | 定义 | 当前（Week 16） | 目标（Week 20） |
|-----------|------|-----------------|-----------------|
| 部署频率 | 多久发布一次 | 每 2 周 | 每 3 天 |
| 变更前置时间 | 从代码提交到部署 | 1 天 | 4 小时 |
| 服务恢复时间 | 出问题多久修复 | 4 小时 | 30 分钟 |
| 变更失败率 | 发布后回滚/热修比例 | 20% | < 15% |

---

### 3. 实验性：用 AI 做 Code Review 第一轮
**目标**：AI 先做初步审查，人类再做深度审查。

**计划**：
- Week 17：配置 GitHub Copilot 或 Claude API 自动审查 PR
- AI 关注：格式、命名、明显的 bug
- 人类关注：设计、边界情况、业务逻辑

**风险**：
- AI 可能漏掉业务逻辑问题
- 团队可能过度信任 AI，减少人工审查深度

**缓解措施**：
- 所有 AI 审查意见必须由人类确认
- 每周抽一个 PR 做"全人工审查"，对比 AI 遗漏率

---

### 4. 引入 Mob Programming（结对编程升级版）
**目标**： Week 08 两人结对效果不错，Week 17 想试试 3 人一起写。

**场景**：
- 复杂功能（如"冲突检测算法"）全员一起设计
- 难题排查（如 Week 12 的性能问题）集体调试
- 新人培训（如 Week 18 如果有新成员）

---

### 5. 参加开源项目
**目标**：把 CampusFlow 开源，体验真实的开源协作。

**计划**：
- Week 17：清理敏感信息，开源到 GitHub
- Week 18：写 CONTRIBUTING.md，定义贡献流程
- Week 19：到其他学校宣传，吸引外部贡献者
- Week 20：处理第一个外部 PR（如果有的话）

**期待收获**：
- 陌生人会用不同的方式提 PR，学习外部代码风格
- Issue 管理经验（如何分类、优先级排序）
- 社区运营经验（如何写"欢迎贡献"）

---

## 附录：16 周 ADR 回顾

| ADR | 标题 | 周次 | 决策 | 后果 |
|-----|------|------|------|------|
| ADR-001 | 领域模型设计 | Week 02 | User + Room + Booking 三层模型 | 清晰，但 Booking 类后来变得复杂 |
| ADR-002 | 数据存储方案 | Week 04 | SQLite（放弃 JSON 文件） | 轻量，但 Week 12 发现并发性能有限 |
| ADR-003 | API 设计风格 | Week 06 | RESTful + OpenAPI 文档 | 规范，但初期学习成本高 |
| ADR-004 | 架构演进 | Week 08 | 引入策略模式处理预约规则 | 代码更灵活，但类数量翻倍 |

**遗憾**：
- 没有记录"撤销决策"（ADR-R）
- ADR-004 的"引入策略模式"其实 Week 12 才实现，延迟了 4 周

---

## 总结

16 周的 CampusFlow 不是"写了一个 Web 应用"，而是**体验了一次完整的软件工程生命周期**。

- Week 02-04：你学会了领域建模，但不知道这个模型会不会变
- Week 05-08：你加了测试、数据库、API，但不知道性能瓶颈在哪
- Week 09-12：你做了前端、AI 协作、集成测试，但不知道用户会不会用
- Week 13-16：你写了文档、发布、展示，但不知道下一步往哪走

**Week 16 的复盘，就是把这一路的"不知道"变成"经验"。**

下个项目，你不会再犯同样的错误——这就是工程成长的意义。

---

## 相关术语

- **回顾桥**：
  - Week 02 的 ADR → Week 16 的 ADR 回顾
  - Week 06 的测试先行 → Week 16 的 87% 覆盖率
  - Week 10 的 AI 审查 → Week 16 的 AI 幻觉反思

- **工程实践**：
  - Feature Branch（Week 04）→ Git 历史清晰（Week 16）
  - Code Review（Week 04）→ AI 辅助审查（Try, Week 17）
  - 质量门禁（Week 11）→ CI/CD（Try, Week 17）

- **软技能**：
  - 技术演示（Week 15）→ Q&A 准备不足（Problem）
  - 团队协作（首席架构师轮换）→ 继续保持（Keep）
