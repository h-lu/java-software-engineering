# Week 04 锚点记录
# 用于把"主张"与"可验证证据"绑定在一起

- id: week-04-list-indexing
  claim: Python 的列表索引从 0 开始，访问不存在的索引会报 IndexError
  evidence: |
    ```python
    scores = [85, 92, 78, 90, 88]
    print(scores[0])  # 85 - 第一个元素
    print(scores[-1])  # 88 - 最后一个元素
    print(scores[5])   # IndexError: list index out of range
    ```
  verification: 运行 02_list_basics.py，观察索引访问行为和错误信息

- id: week-04-list-methods-append
  claim: append() 方法在列表末尾添加一个元素，原地修改列表
  evidence: |
    ```python
    scores = [85, 92, 78]
    scores.append(90)
    # scores 现在是 [85, 92, 78, 90]
    ```
  verification: 在 Python 中验证 append() 不返回新值，而是原地修改列表

- id: week-04-sort-vs-sorted
  claim: sort() 原地修改列表并返回 None，sorted() 返回新列表
  evidence: |
    ```python
    scores = [85, 78, 92]
    result = scores.sort()  # sort() 返回 None
    print(result)  # None

    new_scores = sorted(scores)  # sorted() 返回新列表
    print(new_scores)  # [78, 85, 92]
    ```
  verification: 测试 sort() 的返回值，确认它是 None

- id: week-04-dict-get
  claim: dict.get() 方法在键不存在时返回默认值（默认为 None），不会报错
  evidence: |
    ```python
    scores = {"小北": 85, "阿码": 92}
    print(scores.get("老潘"))  # None - 不会报错
    print(scores.get("老潘", 0))  # 0 - 可以指定默认值
    print(scores["老潘"])  # KeyError - 会报错
    ```
  verification: 对比 get() 和直接访问的区别

- id: week-04-mutability
  claim: 列表和字典是可变对象，字符串和数字是不可变对象
  evidence: |
    ```python
    # 列表是可变的
    scores = [85, 92]
    scores[0] = 90  # 直接修改

    # 字符串是不可变的
    name = "小北"
    name[0] = "大"  # TypeError: 'str' object does not support item assignment
    ```
  verification: 尝试修改字符串的字符，验证 TypeError

- id: week-04-iteration-patterns
  claim: 遍历字典时使用 .items() 可以同时获取键和值
  evidence: |
    ```python
    scores = {"小北": 85, "阿码": 92, "老潘": 88}
    for name, score in scores.items():
        print(f"{name}: {score}")
    ```
  verification: 运行代码，确认可以同时获取键值对

- id: week-04-data-driven-design
  claim: 用数据结构（字典）替代硬编码的条件判断，可以简化代码
  evidence: |
    ```python
    # 不用数据驱动：一堆 if/elif
    if mood == "1":
        advice = "挑战新概念"
    elif mood == "2":
        advice = "做巩固练习"
    elif mood == "3":
        advice = "休息一下"

    # 用数据驱动：一个字典 lookup
    advice_map = {
        "1": "挑战新概念",
        "2": "做巩固练习",
        "3": "休息一下"
    }
    advice = advice_map.get(mood, "做巩固练习")
    ```
  verification: 对比两种实现方式的功能等价性

- id: week-04-ai-tensors
  claim: AI 模型中的张量（tensor）本质上是多维数组，与 Python 列表概念相通
  evidence: NumPy 数组比 Python 列表快 10-20 倍（来源：研究缓存）
  verification: （概念性锚点）阅读 AI 时代小专栏 #1，理解列表→NumPy数组→张量的演进

- id: week-04-llm-dict
  claim: LLM 的分词器（tokenizer）使用类似字典的结构将 token 映射到 ID
  evidence: Tokenizer 本质上是 token 字符串到 token ID 的映射（类似字典的键值对结构）
  verification: （概念性锚点）阅读 AI 时代小专栏 #2，理解字典在 LLM 中的应用
