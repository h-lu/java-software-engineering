# 示例：ADR-002 数据存储方案决策

本示例展示 CampusFlow 团队如何撰写 ADR-002，记录数据存储方案的决策过程。

---

## ADR-002 完整模板

```markdown
# ADR-002: 数据存储方案决策

## 状态
已采纳

## 背景
CampusFlow 目前使用内存存储（ArrayList），程序关闭后数据丢失。
需要选择一种持久化方案，支持数据长期保存和基本查询。

## 决策
我们选择 **SQLite** 作为数据存储方案。

### 实现路径
1. Week 04-05：实现 FileTaskRepository（JSON 文件存储）
   - 作为过渡方案，验证 Repository 接口设计
   - 支持基本 CRUD 操作

2. Week 06-07：实现 SQLiteTaskRepository
   - 替换 FileTaskRepository
   - 利用 SQL 支持复杂查询（按日期范围筛选等）

### 架构设计
```
┌─────────────────┐
│   TaskManager   │
├─────────────────┤
│ - repository:   │
│   TaskRepository│
└────────┬────────┘
         │ 依赖接口
         ▼
┌─────────────────┐
│ TaskRepository  │ ← 接口
│  (interface)    │
└────────┬────────┘
         │ 两种实现
    ┌────┴────┐
    ▼         ▼
┌────────┐ ┌──────────┐
│  File  │ │  SQLite  │
│Repository│ │Repository│
└────────┘ └──────────┘
```

## 理由

### 为什么选 SQLite（而不是内存或纯文件）

1. **数据持久化**：程序关闭后数据不丢失（优于内存）
2. **查询能力**：支持 SQL 查询，便于实现复杂筛选（优于纯文件）
3. **事务支持**：保证数据一致性（优于纯文件）
4. **轻量级**：无需单独安装数据库服务器，适合教学项目
5. **可扩展性**：将来可迁移到 PostgreSQL/MySQL 等生产数据库

### 为什么先实现 FileRepository

1. **渐进式演进**：先验证接口设计，再引入数据库复杂度
2. **教学价值**：让学生理解"接口隔离实现"的好处
3. **回滚能力**：如果 SQLite 实现遇到问题，可以快速回退到文件存储

## 替代方案

### 方案 A：内存存储（不持久化）
- **优点**：最简单
- **缺点**：数据丢失，无法用于真实场景
- **结论**：不采纳——项目目标是可交付的应用，不是演示原型

### 方案 B：纯 JSON 文件存储
- **优点**：实现简单、数据可读
- **缺点**：无查询能力、无事务、并发困难
- **结论**：作为过渡方案采纳，但不是最终方案

### 方案 C：MySQL/PostgreSQL
- **优点**：生产级数据库，功能完善
- **缺点**：需要安装和配置，增加环境复杂度
- **结论**：暂不采纳——超出教学项目范围，Week 08+ 可重新评估

## 后果

### 正面影响
- 数据持久化，支持真实使用场景
- Repository 接口设计得到验证
- 学生掌握 JDBC 和 SQL 基础

### 负面影响
- 增加学习成本（SQL、JDBC）
- 需要处理数据库连接、异常等额外复杂度
- 测试需要设置数据库环境

### 风险与缓解

| 风险 | 可能性 | 影响 | 缓解措施 |
|------|--------|------|----------|
| JDBC 学习曲线陡峭 | 中 | 中 | 提供示例代码和模板 |
| 数据库环境配置问题 | 高 | 低 | 使用 SQLite（嵌入式，无需安装） |
| SQL 注入漏洞 | 中 | 高 | Week 06 专门讲解参数化查询 |

## 验证方式
- [ ] Week 05：FileTaskRepository 实现完成，数据可保存到文件
- [ ] Week 06：SQLiteTaskRepository 实现完成，功能与 File 版本一致
- [ ] Week 07：数据迁移测试（File → SQLite）
- [ ] Week 08：性能对比（File vs SQLite）

## 相关决策
- ADR-001：领域模型设计（定义了 TaskRepository 接口）
- ADR-003（Week 06）：API 设计决策

## 首席架构师
小北 - 第 1 轮（Week 02-03）

## 记录日期
2026-02-11
```

---

## ADR 撰写指南

### 必须由人写的部分

以下部分必须由人撰写，**不能用 AI 代劳**：

1. **背景**：你的项目的具体情况
2. **决策**：基于团队讨论的结论
3. **理由**：为什么选 A 不选 B（业务约束、权衡点）
4. **后果**：对项目的具体影响

### AI 可以辅助的部分

AI 可以帮你：
- 生成 ADR 模板
- 检查语法和格式
- 提供类似项目的参考

### 撰写流程

```
1. 团队讨论 → 2. 人工撰写决策内容 → 3. AI 辅助检查格式 → 4. 团队审阅 → 5. 定稿
```

---

## 常见错误

### 错误 1：只记录结果，不记录过程

```markdown
❌ 不好的 ADR

## 决策
使用 SQLite

## 理由
SQLite 很好。
```

### 错误 2：没有考虑替代方案

```markdown
❌ 不好的 ADR

## 决策
使用 SQLite

## 理由
1. 支持 SQL
2. 轻量级

（缺少替代方案对比）
```

### 错误 3：没有记录负面影响

```markdown
❌ 不好的 ADR

## 后果
### 正面影响
- 数据持久化
- 查询能力强

（缺少负面影响）
```

---

## 为什么 ADR 很重要

> **"决策记录比决策结果更重要。"**

1. **避免重复讨论**：三个月后有人问"为什么用 SQLite"，直接看 ADR
2. **支持重新评估**：当条件变化时，知道当初为什么这样决定
3. **知识传承**：新成员快速了解项目决策历史
4. **责任明确**：记录决策者和日期，明确责任

---

## ADR 文件命名规范

```
docs/adr/
├── 001-领域模型设计.md
├── 002-数据存储方案.md
├── 003-api设计决策.md
└── 004-xxx.md
```

- 编号连续，从 001 开始
- 文件名简短，用中文描述主题
- 使用 Markdown 格式
