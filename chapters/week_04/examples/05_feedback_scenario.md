# 示例：建设性反馈的对话场景

本示例展示 CampusFlow 团队在 Code Review 中如何处理技术分歧，给出建设性反馈。

---

## 场景 1：发现潜在 Bug

### 背景

小北提交了任务筛选功能，阿码在 Code Review 中发现潜在的 NPE 问题。

---

### 不好的反馈方式

**阿码**：这里会 NPE，你代码写错了。

**小北**：哪里错了？我觉得没问题啊。

**阿码**：你自己看，第 5 行。

**小北**：（感到被攻击）我测试过了，不会出错的。

**结果**：讨论陷入僵局，气氛紧张。

---

### 好的反馈方式

**阿码**：如果 `priority` 参数为 null，`task.getPriority().equals(priority)` 会抛出 NPE（第 5 行）。建议添加前置检查：

```java
public List<Task> filterByPriority(String priority) {
    if (priority == null) {
        throw new IllegalArgumentException("优先级不能为 null");
    }
    // ...
}
```

或者考虑使用 `Objects.equals()` 来避免空指针。你觉得哪种方式更适合这个场景？

**小北**：啊，你说得对，我没考虑到 null 的情况。我觉得第一种方式更好，可以明确告诉调用者参数要求。我立即修改。

**阿码**：好的，修改后我再看一下。

**结果**：问题被友好地指出并解决，双方都感到被尊重。

---

## 场景 2：技术分歧——类职责划分

### 背景

小北在 `TaskManager` 中添加了筛选功能，阿码认为应该拆分到单独的 `TaskFilter` 类。

---

### 对话过程

**阿码**：我注意到 `TaskManager` 现在有 6 个方法了——添加、删除、标记完成、筛选... 它是不是承担了太多职责？按照 Week 02 学的 SRP，筛选功能是否应该拆分到单独的 `TaskFilter` 类？

**小北**：你说得有道理，但我现在只是添加两个筛选方法，拆分会增加复杂度。而且当前的需求比较简单，拆分是否过早优化了？

**阿码**：这是个好问题。我担心的是，如果后续再添加按日期筛选、按标签筛选，`TaskManager` 会变得很臃肿。你觉得未来会添加更多筛选条件吗？

**小北**：应该会。用户还提过想要按日期范围和标签筛选。

**阿码**：那我们可以这样：现在保持现状，但在代码里加一个 TODO 注释，说明当筛选方法超过 5 个时拆分到 `TaskFilter` 类。同时在 ADR-002 里记录这个技术债，避免忘记。

**小北**：好主意！这样既不增加当前复杂度，又留下了重构的信号。我来加 TODO 和 ADR 记录。

**阿码**：完美。另外，如果将来拆分，`TaskFilter` 可以设计成纯函数，不依赖状态，测试起来会更简单。

**小北**：学到了！我加到注释里。

---

### 关键技巧

1. **引用共同知识**：阿码提到 "Week 02 学的 SRP"，建立共识基础
2. **提问而非断言**："是否应该拆分？" 比 "你应该拆分" 更容易接受
3. **寻找折中**：不是非黑即白，而是 "现在保持现状 + TODO + ADR 记录"
4. **提供额外价值**：阿码补充了 "纯函数" 的设计建议

---

## 场景 3：处理激烈分歧——Lombok 之争

### 背景

团队就是否引入 Lombok 产生分歧，阿码支持，小北反对，讨论逐渐升温。

---

### 对话过程

**阿码**：Lombok 可以自动生成 getter、setter、toString，减少很多重复代码。我们应该引入。

**小北**：但它隐藏了实现细节，新人可能不知道 `@Data` 注解到底生成了什么方法。而且 Week 02 我们强调过"手写 getter/setter 有助于理解封装"。

**阿码**：手写太浪费时间了，都是样板代码。

**小北**：浪费时间比造成理解障碍好。团队里还有新人，他们需要看到完整的代码。

（气氛开始紧张）

**老潘**：（介入）你们两个都没错，只是权衡点不同。阿码考虑的是开发效率，小北考虑的是可理解性和团队成长。

让我问几个问题帮助你们理清思路：

1. **我们的首要目标是可维护性还是快速交付？**（当前阶段）
2. **团队规模会快速增长吗？**（如果有 10 个新人，Lombok 的学习成本会更高）
3. **有没有数据支持你们的观点？**（比如引入 Lombok 后 onboarding 时间会增加多少？）

**阿码**：我们目前只有 3 个人，但计划下学期扩展到 10 人。

**小北**：而且这是教学项目，理解原理比开发效率更重要。

**老潘**：那我们可以这样决策：
- **现在**：不引入 Lombok，手写 getter/setter（教学优先）
- **触发条件**：当团队规模超过 5 人，或代码量超过 5000 行时重新评估
- **替代方案**：使用 IDE 自动生成（Alt+Insert），既快速又可见

这个决策记录在开发规范中，三个月后回顾。

**阿码**：我接受这个决策。虽然我更看重效率，但理解 "教学优先" 的约束。

**小北**：我也同意。当团队扩大后，我们可以重新评估。

---

### 老潘的处理技巧

1. **肯定双方**："你们两个都没错"
2. **明确分歧本质**："权衡点不同"，不是对错之争
3. **提问引导**：用问题帮助双方理清假设
4. **量化因素**：团队规模、代码量等具体数字
5. **记录决策**：不是"谁赢了"，而是"在什么条件下重新评估"
6. **设定回顾点**：避免决策成为永久枷锁

---

## 建设性反馈的原则总结

| 原则 | 不好的做法 | 好的做法 |
|------|-----------|---------|
| **对事不对人** | "你这里写错了" | "这段代码可能会导致 NPE" |
| **解释原因** | "不要用魔法数字" | "提取为常量，业务规则变化时只需改一处" |
| **承认不确定性** | "这样肯定不行" | "我不确定这个设计在并发场景下是否安全" |
| **提供选项** | "你必须改成 A" | "A 方案简单，B 方案灵活，我倾向于 A，你觉得呢？" |
| **肯定好的部分** | （只挑错） | "这个异常处理很完善，考虑了多种情况" |

---

## 决策记录模板

当技术分歧无法达成一致时，使用以下模板记录决策：

```markdown
# 决策：暂不引入 Lombok

## 提议者
阿码

## 反对者
小北

## 决策理由
1. 教学阶段，手写 getter/setter 有助于理解封装原理
2. 团队规模小（3 人），样板代码量可控
3. 避免引入额外依赖（Lombok 需要 IDE 插件支持）

## 替代方案
- 使用 IDE 自动生成 getter/setter（IntelliJ: Alt+Insert）

## 触发重新评估的条件
- 团队规模超过 5 人
- 代码量超过 5000 行
- 日期：2026-05-11（三个月后）

## 决策者
首席架构师（小北）

## 日期
2026-02-11
```

---

## 关键结论

> Code Review 的目的是**提高代码质量**，不是**证明谁更聪明**。

当团队成员感到被攻击时，他们会：
- 防御性回复
- 避免提交 PR
- 隐藏问题而不是暴露问题

建设性反馈创造的是**心理安全**的环境，让每个人都能从错误中学习，让技术分歧变成学习机会。
