# ADR-001: [项目名] [决策主题]

## 状态
已采纳 / 已废弃 / 已替代 / 待定

## 背景
[描述当前的问题或需求背景]

## 决策
[清晰描述你的决策是什么]

### 核心设计
```
[如果有架构图或类图，放在这里]

示例：
┌─────────────────┐
│    TaskManager  │ (管理类)
├─────────────────┤
│ - tasks: List   │
│ + addTask()     │
│ + markComplete()│
│ + filter()      │
└────────┬────────┘
         │ 使用
         ▼
┌─────────────────┐
│      Task       │ (实体类)
├─────────────────┤
│ - title: String │
│ - completed:    │
│   boolean       │
│ + getTitle()    │
│ + markComplete()│
└─────────────────┘
```

### 设计原则
- 遵循单一职责原则（SRP）：每个类只负责一个职责
- 遵循开闭原则（OCP）：通过接口扩展功能，而不是修改现有代码
- 封装：private 字段 + public 方法

## 理由
[说明为什么做这个决策]

1. **理由 1**：[具体说明]
2. **理由 2**：[具体说明]
3. **理由 3**：[具体说明]

## 替代方案

### 方案 A：[方案名称]
- **优点**：[说明优点]
- **缺点**：[说明缺点]
- **结论**：采纳 / 不采纳 / 暂不采纳

### 方案 B：[方案名称]
- **优点**：[说明优点]
- **缺点**：[说明缺点]
- **结论**：采纳 / 不采纳 / 暂不采纳

### 方案 C：[方案名称]
- **优点**：[说明优点]
- **缺点**：[说明缺点]
- **结论**：采纳 / 不采纳 / 暂不采纳

## 后果

### 正面影响
- [说明这个决策带来的好处]
- [说明可维护性提升]
- [说明可扩展性提升]

### 负面影响
- [说明这个决策的代价]
- [说明可能的性能影响]
- [说明开发时间增加]

### 风险
- [识别潜在风险]
- **缓解措施**：[如何降低风险]

## 验证方式
- [ ] Week 02：[如何验证这个设计]
- [ ] Week 04：[如何验证设计是否符合预期]
- [ ] Week 07：[如何验证可扩展性]
- [ ] Week 12：[代码审查检查点]

## 相关决策
- ADR-002（Week 04）：[相关决策]
- ADR-003（Week 06）：[相关决策]

## 首席架构师
[姓名] - 第 [X] 轮（Week XX-XX）

## 记录日期
YYYY-MM-DD

---

## 使用说明

### ADR 是什么？
ADR（Architecture Decision Record，架构决策记录）是一个轻量级文档，记录重要的架构决策及其背景。

### 为什么需要 ADR？
- **代码告诉你"怎么做"，ADR 告诉你"为什么做"**
- 三个月后，你和你的同事需要知道"为什么这样设计"
- 防止自作聪明地改坏代码（破坏设计约束）

### ADR 的核心思想

| 内容 | 说明 |
|------|------|
| **我们要做什么** | 决策的内容 |
| **为什么要这样做** | 背景和动机 |
| **为什么不那样做** | 考虑过的其他方案 |
| **有什么后果** | 这个决策的影响 |
| **怎么验证** | 后续如何验证这个决策是否正确 |

### ADR 和锚点的关系

ADR 是锚点的**具体实践**：

| 锚点要素 | ADR 中的对应 |
|---------|-------------|
| 主张（claim） | "决策"部分 |
| 理由（reason） | "理由"部分 |
| 替代方案（alternatives） | "替代方案"部分 |
| 可验证证据（evidence） | "验证方式"部分 |

### 最佳实践

1. **保持轻量**
   - ADR 不是学术论文，不需要长篇大论
   - 一页 Markdown 足够记录一个决策
   - 重点写"为什么"和"替代方案"

2. **记录决策过程，不只是结果**
   - 不要只写"我们选择了方案 A"
   - 要写"为什么选 A 而不是 B"——这是最有价值的信息

3. **ADR 是活的文档**
   - 决策不是永久的，可以变更
   - 如果后来发现 ADR-001 的决策有问题，写 ADR-005 记录"为什么废弃 ADR-001"
   - ADR 的历史记录比"最新的正确答案"更有价值

4. **由首席架构师负责**
   - ADR 必须由人写，不能用 AI 代劳
   - 首席架构师负责撰写，但团队参与讨论
   - **ADR 记录的是团队的集体决策，不是某个人的想法**

5. **ADR 不能用 AI 代劳**
   - AI 可以帮你润色语言、检查格式
   - 但**不能帮你做决策**
   - ADR 记录的是**你的团队的决策过程**，不是某个通用答案

### 示例：TaskManager ADR-001

```markdown
# ADR-001: TaskManager 领域模型设计

## 状态
已采纳

## 背景
CampusFlow 项目小组选择了"TaskFlow"（个人任务管理）作为选题。需要设计核心的领域模型，支撑任务创建、管理、持久化等功能。

## 决策

### 核心类设计
```
┌─────────────────┐
│    TaskManager  │ (管理类)
├─────────────────┤
│ - tasks: List   │
│ + addTask()     │
│ + markComplete()│
│ + filter()      │
└────────┬────────┘
         │ 使用
         ▼
┌─────────────────┐
│      Task       │ (实体类)
├─────────────────┤
│ - title: String │
│ - completed:    │
│   boolean       │
│ + getTitle()    │
│ + markComplete()│
└─────────────────┘
```

### 职责分配
- **Task**：只负责存储任务数据（封装）
- **TaskManager**：负责管理任务的增删改查（服务）
- **TaskValidator**：负责验证数据合法性（验证）
- **TaskPrinter**：负责格式化输出（显示）

## 理由
1. **单一职责**：每个类只负责一件事，便于理解和测试
2. **封装保护**：private 字段防止数据被意外破坏
3. **可扩展性**：将来可以轻松添加新功能（比如 TaskRepository 持久化）

## 替代方案

### 方案 A：全部 public 字段
- **优点**：代码少，写起来快
- **缺点**：数据不安全，无法控制变化
- **结论**：不采纳——违反封装原则

## 后果
- 正面：代码结构清晰，职责分明，易于维护
- 负面：类数量增多，初期开发时间增加约 30%
- 风险：团队可能过度设计——缓解：每个功能需求对应一个类

## 验证方式
- [ ] Week 02：TaskManager 能正常运行（交互式菜单）
- [ ] Week 04：代码审查，检查是否符合单一职责原则
- [ ] Week 07：添加 TaskRepository 时，验证 Task 类设计是否便于持久化

## 首席架构师
张三 - 第 1 轮（Week 02-03）

## 记录日期
2026-02-11
```
